package main

import (
	"bytes"
	"testing"
)

var TestBlkBlockBytes = []byte{
	0xf9, 0xbe, 0xb4, 0xd9, 0xd7, 0x00, 0x00, 0x00,
	0x01, 0x00, 0x00, 0x00, 0x6f, 0xe2, 0x8c, 0x0a,
	0xb6, 0xf1, 0xb3, 0x72, 0xc1, 0xa6, 0xa2, 0x46,
	0xae, 0x63, 0xf7, 0x4f, 0x93, 0x1e, 0x83, 0x65,
	0xe1, 0x5a, 0x08, 0x9c, 0x68, 0xd6, 0x19, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x98, 0x20, 0x51, 0xfd,
	0x1e, 0x4b, 0xa7, 0x44, 0xbb, 0xbe, 0x68, 0x0e,
	0x1f, 0xee, 0x14, 0x67, 0x7b, 0xa1, 0xa3, 0xc3,
	0x54, 0x0b, 0xf7, 0xb1, 0xcd, 0xb6, 0x06, 0xe8,
	0x57, 0x23, 0x3e, 0x0e, 0x61, 0xbc, 0x66, 0x49,
	0xff, 0xff, 0x00, 0x1d, 0x01, 0xe3, 0x62, 0x99,
	0x01, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,
	0xff, 0xff, 0x07, 0x04, 0xff, 0xff, 0x00, 0x1d,
	0x01, 0x04, 0xff, 0xff, 0xff, 0xff, 0x01, 0x00,
	0xf2, 0x05, 0x2a, 0x01, 0x00, 0x00, 0x00, 0x43,
	0x41, 0x04, 0x96, 0xb5, 0x38, 0xe8, 0x53, 0x51,
	0x9c, 0x72, 0x6a, 0x2c, 0x91, 0xe6, 0x1e, 0xc1,
	0x16, 0x00, 0xae, 0x13, 0x90, 0x81, 0x3a, 0x62,
	0x7c, 0x66, 0xfb, 0x8b, 0xe7, 0x94, 0x7b, 0xe6,
	0x3c, 0x52, 0xda, 0x75, 0x89, 0x37, 0x95, 0x15,
	0xd4, 0xe0, 0xa6, 0x04, 0xf8, 0x14, 0x17, 0x81,
	0xe6, 0x22, 0x94, 0x72, 0x11, 0x66, 0xbf, 0x62,
	0x1e, 0x73, 0xa8, 0x2c, 0xbf, 0x23, 0x42, 0xc8,
	0x58, 0xee, 0xac, 0x00, 0x00, 0x00, 0x00,
}

var TestBlkBlock = &BlkBlock{
	MagicBytes: []byte{0xf9, 0xbe, 0xb4, 0xd9},
	Size: 215,
	Block: &Block{
		BlockHeader: &BlockHeader{
			Version: 1,
			PrevBlockHeaderHash: []byte{
				0x00, 0x00, 0x00, 0x00, 0x00, 0x19, 0xd6, 0x68,
				0x9c, 0x08, 0x5a, 0xe1, 0x65, 0x83, 0x1e, 0x93,
				0x4f, 0xf7, 0x63, 0xae, 0x46, 0xa2, 0xa6, 0xc1,
				0x72, 0xb3, 0xf1, 0xb6, 0x0a, 0x8c, 0xe2, 0x6f,
			},
			MerkleRootHash: []byte{
				0x0e, 0x3e, 0x23, 0x57, 0xe8, 0x06, 0xb6, 0xcd,
				0xb1, 0xf7, 0x0b, 0x54, 0xc3, 0xa3, 0xa1, 0x7b,
				0x67, 0x14, 0xee, 0x1f, 0x0e, 0x68, 0xbe, 0xbb,
				0x44, 0xa7, 0x4b, 0x1e, 0xfd, 0x51, 0x20, 0x98,
			},
			Time:  1231469665,
			NBits: 486604799,
			Nonce: 2573394689,
		},
		Hash: []byte{
			0x00, 0x00, 0x00, 0x00, 0x83, 0x9a, 0x8e, 0x68,
			0x86, 0xab, 0x59, 0x51, 0xd7, 0x6f, 0x41, 0x14,
			0x75, 0x42, 0x8a, 0xfc, 0x90, 0x94, 0x7e, 0xe3,
			0x20, 0x16, 0x1b, 0xbf, 0x18, 0xeb, 0x60, 0x48,
		},
		TxnCount: 1,
		Txns: []*Transaction{
			{
				Hash: []byte{
					0x0e, 0x3e, 0x23, 0x57, 0xe8, 0x06, 0xb6, 0xcd,
					0xb1, 0xf7, 0x0b, 0x54, 0xc3, 0xa3, 0xa1, 0x7b,
					0x67, 0x14, 0xee, 0x1f, 0x0e, 0x68, 0xbe, 0xbb,
					0x44, 0xa7, 0x4b, 0x1e, 0xfd, 0x51, 0x20, 0x98,
				},
				Version:    1,
				TxInCount:  1,
				TxOutCount: 1,
				LockTime:   0,
				TxIn: []*TxInput{
					{
						Hash: []byte{
							0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
							0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
							0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
							0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
						},
						Index:           4294967295,
						ScriptBytes:     7,
						SignatureScript: []byte{0x04, 0xff, 0xff, 0x00, 0x1d, 0x01, 0x04},
						Sequence:        4294967295,
					},
				},
				TxOut: []*TxOutput{
					{
						Value:         5000000000,
						PkScriptBytes: 67,
						PkScript: &PKScript{
							PkScript: []byte{
								0x41, 0x04, 0x96, 0xb5, 0x38, 0xe8, 0x53, 0x51,
								0x9c, 0x72, 0x6a, 0x2c, 0x91, 0xe6, 0x1e, 0xc1,
								0x16, 0x00, 0xae, 0x13, 0x90, 0x81, 0x3a, 0x62,
								0x7c, 0x66, 0xfb, 0x8b, 0xe7, 0x94, 0x7b, 0xe6,
								0x3c, 0x52, 0xda, 0x75, 0x89, 0x37, 0x95, 0x15,
								0xd4, 0xe0, 0xa6, 0x04, 0xf8, 0x14, 0x17, 0x81,
								0xe6, 0x22, 0x94, 0x72, 0x11, 0x66, 0xbf, 0x62,
								0x1e, 0x73, 0xa8, 0x2c, 0xbf, 0x23, 0x42, 0xc8,
								0x58, 0xee, 0xac,
							},
							Pops: []*parsedOpcode{
								{
									Opcode: &opcodeArray[OP_DATA_65],
									Data: []byte{
										0x04, 0x96, 0xb5, 0x38, 0xe8, 0x53, 0x51, 0x9c,
										0x72, 0x6a, 0x2c, 0x91, 0xe6, 0x1e, 0xc1, 0x16,
										0x00, 0xae, 0x13, 0x90, 0x81, 0x3a, 0x62, 0x7c,
										0x66, 0xfb, 0x8b, 0xe7, 0x94, 0x7b, 0xe6, 0x3c,
										0x52, 0xda, 0x75, 0x89, 0x37, 0x95, 0x15, 0xd4,
										0xe0, 0xa6, 0x04, 0xf8, 0x14, 0x17, 0x81, 0xe6,
										0x22, 0x94, 0x72, 0x11, 0x66, 0xbf, 0x62, 0x1e,
										0x73, 0xa8, 0x2c, 0xbf, 0x23, 0x42, 0xc8, 0x58,
										0xee,
									},
								},
								{
									Opcode: &opcodeArray[OP_CHECKSIG],
									Data:   []byte{},
								},
							},
							Stype:     PubKey,
							Addresses: []string{"12c6DSiU4Rq3P4ZxziKxzrL5LmMBrzjrJX"},
						},
					},
				},
			},
		},
	},
}

func TestDeserializeBlkBlock(t *testing.T) {
	blkblock, size, err:= DeserializeBlkBlock(TestBlkBlockBytes)
	if err != nil {
		t.Errorf("TestDeserializeBlkBlock error: %s", err)
	}
	if size != len(TestBlkBlockBytes) {
		t.Errorf("size is not correct, we got: %d, but answer is: %d",size, len(TestBlkBlockBytes))
	}
	CompareBlkBlock(blkblock,TestBlkBlock,t)
}

func TestBlkBlock_Serialize(t *testing.T) {
	sb, err:= TestBlkBlock.Serialize()
	if err != nil {
		t.Errorf("TestBlkBlock_Serialize error: %s", err)
	}
	if bytes.Compare(sb,TestBlkBlockBytes) != 0 {
		t.Errorf("bytes are not correct, we got: %d, but answer is: %d",sb, len(TestBlkBlockBytes))

	}
}

func CompareBlkBlock(got *BlkBlock, ans *BlkBlock, t *testing.T) {
	if got.Size != ans.Size {
		t.Errorf("size is not correct, we got: %d, but answer is: %d",got.Size, ans.Size)
	}
	if bytes.Compare(got.MagicBytes, ans.MagicBytes) != 0 {
		t.Errorf("MagicBytes is not correct, we got: %x, but answer is: %x",got.MagicBytes, ans.MagicBytes)
	}
	CompareBlock(got.Block,ans.Block,t)
}